#![deny(warnings, missing_debug_implementations)]

//! apllodb's client bin crate.

use apllodb_rpc_interface::ApllodbRpcClient;
use apllodb_shared_components::{ApllodbResult, DatabaseName, Session};
use clap::{App, Arg};
use std::net::SocketAddr;
use tarpc::{client, context};
use tokio_serde::formats::Bincode;

#[tokio::main]
async fn main() -> ApllodbResult<()> {
    env_logger::init();

    let flags = App::new("apllodb-client")
        .arg(
            Arg::with_name("server_addr")
                .long("server_addr")
                .value_name("ADDRESS")
                .help("Sets the server address to connect to.")
                .required(true)
                .takes_value(true),
        )
        .arg(
            Arg::with_name("db")
                .long("db")
                .value_name("STRING")
                .help("Database name to use.")
                .required(true)
                .takes_value(true),
        )
        .arg(
            Arg::with_name("sql")
                .long("sql")
                .value_name("STRING")
                .help("Single SQL command.")
                .required(true)
                .takes_value(true),
        )
        .get_matches();

    let server_addr = flags.value_of("server_addr").unwrap();
    let server_addr = server_addr
        .parse::<SocketAddr>()
        .unwrap_or_else(|e| panic!(r#"--server_addr value "{}" invalid: {}"#, server_addr, e));

    let db = DatabaseName::new(flags.value_of("db").unwrap()).unwrap();
    let sql = flags.value_of("sql").unwrap();

    let mut transport = tarpc::serde_transport::tcp::connect(server_addr, Bincode::default);
    transport.config_mut().max_frame_length(4294967296);

    // WorldClient is generated by the service attribute. It has a constructor `new` that takes a
    // config and any Transport as input.
    let mut client = ApllodbRpcClient::new(client::Config::default(), transport.await?).spawn()?;

    // The client has an RPC method for each RPC defined in the annotated trait. It takes the same
    // args as defined, with the addition of a Context, which is always the first arg. The Context
    // specifies a deadline and trace information which can be helpful in debugging requests.
    let session = client.begin_transaction(context::current(), db).await??;

    let resp = client
        .command(
            context::current(),
            Session::WithTx(session),
            sql.to_string(),
        )
        .await?;

    println!("{:?}", resp);

    Ok(())
}
