use super::ApllodbImmutableSchemaEngine;

use apllodb_storage_engine_interface::StorageEngine;
use futures::prelude::*;
use std::{
    net::SocketAddr,
    {cell::RefCell, rc::Rc},
};
use tarpc::server::{Channel, Handler};
use tokio_serde::formats::Bincode;

use crate::sqlite::sqlite_resource_pool::SqliteResourcePool;

impl ApllodbImmutableSchemaEngine {
    pub async fn serve(addr: SocketAddr) -> Result<(), std::io::Error> {
        let listener = tarpc::serde_transport::tcp::listen(&addr, Bincode::default).await?;

        listener
            // Ignore accept errors.
            .filter_map(|r| future::ready(r.ok()))
            .map(tarpc::server::BaseChannel::with_defaults)
            // Limit channels to 2 per IP.
            .max_channels_per_key(2, |t| t.as_ref().peer_addr().unwrap().ip())
            // serve is generated by the service attribute. It takes as input any type implementing
            // the generated World trait.
            .map(|channel| {
                let server = Self {
                    addr: channel.as_ref().as_ref().peer_addr().unwrap(),
                    pool: Rc::new(RefCell::new(SqliteResourcePool::default())),
                };
                channel
                    .respond_with(server.serve())
                    .try_for_each(|request_handler| async move {
                        request_handler.await;
                        Ok(())
                    })
                    .map_ok(|()| log::info!("ClientHandler finished."))
                    .unwrap_or_else(|e| log::info!("ClientHandler errored out: {}", e))
            })
            // Max 10 channels.
            .buffer_unordered(10)
            .for_each(|_| async {})
            .await;

        Ok(())
    }
}
